name: Release Pipeline

on:
  push:
    tags:
      - 'v*'
      - 'release/*'
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release'
        required: true
        default: 'minor'
        type: choice
        options:
          - major
          - minor
          - patch
          - hotfix
      environment:
        description: 'Target environment for release'
        required: true
        default: 'prod'
        type: choice
        options:
          - staging
          - prod

permissions:
  contents: write
  packages: write
  deployments: write

env:
  RELEASE_BRANCH: 'release'
  HOTFIX_BRANCH: 'hotfix'

jobs:
  # Equivalent to Jenkins Release stage preparation
  prepare-release:
    name: Prepare Release
    runs-on: ubuntu-latest
    outputs:
      release-version: ${{ steps.version.outputs.version }}
      release-type: ${{ steps.version.outputs.type }}
      is-hotfix: ${{ steps.version.outputs.is-hotfix }}
      previous-version: ${{ steps.version.outputs.previous-version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine release version
        id: version
        run: |
          IS_HOTFIX="false"
          RELEASE_TYPE="${{ inputs.release_type || 'minor' }}"
          
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
            if [[ "$VERSION" == *"hotfix"* ]]; then
              IS_HOTFIX="true"
              RELEASE_TYPE="hotfix"
            fi
          else
            # Generate version based on input type
            CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            CURRENT_VERSION=${CURRENT_VERSION#v}
            
            IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
            MAJOR=${VERSION_PARTS[0]:-0}
            MINOR=${VERSION_PARTS[1]:-0}
            PATCH=${VERSION_PARTS[2]:-0}
            
            case "$RELEASE_TYPE" in
              major)
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              minor)
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              patch|hotfix)
                PATCH=$((PATCH + 1))
                if [ "$RELEASE_TYPE" == "hotfix" ]; then
                  IS_HOTFIX="true"
                fi
                ;;
            esac
            
            VERSION="v$MAJOR.$MINOR.$PATCH"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          echo "is-hotfix=$IS_HOTFIX" >> $GITHUB_OUTPUT
          echo "previous-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          
          echo "Release version: $VERSION"
          echo "Release type: $RELEASE_TYPE"
          echo "Is hotfix: $IS_HOTFIX"

  # Build release artifacts
  build-release:
    name: Build Release Artifacts
    uses: ./.github/workflows/ci.yml
    needs: prepare-release
    with:
      skip-deployment: true
    secrets: inherit

  # Generate release notes and changelog
  generate-release-notes:
    name: Generate Release Notes
    runs-on: ubuntu-latest
    needs: prepare-release
    outputs:
      release-notes: ${{ steps.notes.outputs.notes }}
      changelog: ${{ steps.changelog.outputs.changelog }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate release notes
        id: notes
        run: |
          RELEASE_VERSION="${{ needs.prepare-release.outputs.release-version }}"
          PREVIOUS_VERSION="${{ needs.prepare-release.outputs.previous-version }}"
          RELEASE_TYPE="${{ needs.prepare-release.outputs.release-type }}"
          
          # Generate comprehensive release notes
          cat > release-notes.md << EOF
          # Release $RELEASE_VERSION
          
          **Release Type:** $RELEASE_TYPE
          **Previous Version:** $PREVIOUS_VERSION
          **Release Date:** $(date -u +%Y-%m-%d)
          **Build Number:** ${{ github.run_number }}
          
          ## ðŸš€ What's New
          
          EOF
          
          # Add commit messages since last release
          if [ "$PREVIOUS_VERSION" != "v0.0.0" ]; then
            echo "### Changes since $PREVIOUS_VERSION" >> release-notes.md
            git log --pretty=format:"- %s (%h)" v${PREVIOUS_VERSION}..HEAD >> release-notes.md
          else
            echo "### Initial Release" >> release-notes.md
            echo "- First release of Signant Health Demo application" >> release-notes.md
          fi
          
          cat >> release-notes.md << EOF
          
          ## ðŸ”§ Technical Details
          
          - **Commit SHA:** ${{ github.sha }}
          - **Branch:** ${{ github.ref_name }}
          - **Build Artifacts:** Java, Node.js, Python components
          - **Deployment Strategy:** Blue-Green (Production)
          
          ## ðŸ“Š Quality Metrics
          
          - All tests passing âœ…
          - Code coverage meets requirements âœ…
          - Security scans passed âœ…
          - SonarCloud quality gate passed âœ…
          
          ## ðŸ”„ Rollback Plan
          
          If issues are discovered after deployment:
          1. Use Azure App Service deployment slots to switch back
          2. Database migrations (if any) have been designed to be backward compatible
          3. Previous version artifacts are retained for 90 days
          
          EOF
          
          # Output for GitHub
          {
            echo 'notes<<EOF'
            cat release-notes.md
            echo 'EOF'
          } >> $GITHUB_OUTPUT

      - name: Generate changelog
        id: changelog
        run: |
          RELEASE_VERSION="${{ needs.prepare-release.outputs.release-version }}"
          PREVIOUS_VERSION="${{ needs.prepare-release.outputs.previous-version }}"
          
          # Update CHANGELOG.md
          if [ ! -f CHANGELOG.md ]; then
            cat > CHANGELOG.md << EOF
          # Changelog
          
          All notable changes to this project will be documented in this file.
          
          The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
          and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
          
          EOF
          fi
          
          # Add new release entry
          TEMP_CHANGELOG=$(mktemp)
          cat > $TEMP_CHANGELOG << EOF
          # Changelog
          
          All notable changes to this project will be documented in this file.
          
          ## [$RELEASE_VERSION] - $(date -u +%Y-%m-%d)
          
          EOF
          
          # Categorize commits
          if [ "$PREVIOUS_VERSION" != "v0.0.0" ]; then
            echo "### Added" >> $TEMP_CHANGELOG
            git log --pretty=format:"- %s" --grep="feat\|add" v${PREVIOUS_VERSION}..HEAD >> $TEMP_CHANGELOG || echo "- No new features" >> $TEMP_CHANGELOG
            echo -e "\n" >> $TEMP_CHANGELOG
            
            echo "### Changed" >> $TEMP_CHANGELOG
            git log --pretty=format:"- %s" --grep="change\|update\|modify" v${PREVIOUS_VERSION}..HEAD >> $TEMP_CHANGELOG || echo "- No changes" >> $TEMP_CHANGELOG
            echo -e "\n" >> $TEMP_CHANGELOG
            
            echo "### Fixed" >> $TEMP_CHANGELOG
            git log --pretty=format:"- %s" --grep="fix\|bug" v${PREVIOUS_VERSION}..HEAD >> $TEMP_CHANGELOG || echo "- No fixes" >> $TEMP_CHANGELOG
            echo -e "\n" >> $TEMP_CHANGELOG
          else
            echo "### Added" >> $TEMP_CHANGELOG
            echo "- Initial release of Signant Health Demo application" >> $TEMP_CHANGELOG
            echo -e "\n" >> $TEMP_CHANGELOG
          fi
          
          # Append existing changelog
          tail -n +4 CHANGELOG.md >> $TEMP_CHANGELOG
          mv $TEMP_CHANGELOG CHANGELOG.md
          
          echo "changelog=updated" >> $GITHUB_OUTPUT

      - name: Upload release notes
        uses: actions/upload-artifact@v4
        with:
          name: release-notes
          path: |
            release-notes.md
            CHANGELOG.md

  # Create GitHub release
  create-github-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [prepare-release, build-release, generate-release-notes]
    outputs:
      release-id: ${{ steps.release.outputs.id }}
      release-url: ${{ steps.release.outputs.html_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download release notes
        uses: actions/download-artifact@v4
        with:
          name: release-notes

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: build-artifacts-*
          merge-multiple: true
          path: ./release-artifacts

      - name: Create release tag
        if: github.event_name == 'workflow_dispatch'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ needs.prepare-release.outputs.release-version }}" -m "Release ${{ needs.prepare-release.outputs.release-version }}"
          git push origin "${{ needs.prepare-release.outputs.release-version }}"

      - name: Create GitHub Release
        id: release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.prepare-release.outputs.release-version }}
          release_name: "Signant Health Demo ${{ needs.prepare-release.outputs.release-version }}"
          body_path: release-notes.md
          draft: false
          prerelease: ${{ needs.prepare-release.outputs.is-hotfix == 'true' }}

      - name: Upload release artifacts
        run: |
          RELEASE_ID="${{ steps.release.outputs.id }}"
          
          # Upload all build artifacts to the release
          for artifact in release-artifacts/*; do
            if [ -f "$artifact" ]; then
              filename=$(basename "$artifact")
              echo "Uploading $filename..."
              
              curl -X POST \
                -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Content-Type: application/octet-stream" \
                --data-binary @"$artifact" \
                "https://uploads.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID/assets?name=$filename"
            fi
          done

  # Deploy to production (or staging for testing releases)
  deploy-release:
    name: Deploy Release
    needs: [prepare-release, create-github-release]
    uses: ./.github/workflows/deploy.yml
    with:
      environment: ${{ inputs.environment || 'prod' }}
      build_number: ${{ github.run_number }}
      commit_sha: ${{ github.sha }}
      create_feature_release: false
    secrets: inherit

  # Post-release validation
  post-release-validation:
    name: Post-Release Validation
    runs-on: ubuntu-latest
    needs: [prepare-release, deploy-release]
    environment: ${{ inputs.environment || 'prod' }}
    steps:
      - name: Extended health checks
        run: |
          TARGET_ENV="${{ inputs.environment || 'prod' }}"
          
          # Extended health checks for production release
          echo "Running extended health checks for $TARGET_ENV environment..."
          
          # Simulate extended health checks
          sleep 60
          
          echo "âœ… Extended health checks passed"

      - name: Performance validation
        run: |
          echo "Running performance validation..."
          
          # Simulate performance tests
          # In real implementation, you would run actual performance tests
          sleep 30
          
          echo "âœ… Performance validation passed"

      - name: Monitor for errors
        run: |
          echo "Monitoring for errors in the first 5 minutes..."
          
          # Monitor application logs for errors
          sleep 300
          
          echo "âœ… No critical errors detected"

  # Create release branches for hotfixes (production only)
  create-release-branch:
    name: Create Release Branch
    runs-on: ubuntu-latest
    needs: [prepare-release, post-release-validation]
    if: inputs.environment == 'prod' || github.ref_type == 'tag'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create release branch
        run: |
          RELEASE_VERSION="${{ needs.prepare-release.outputs.release-version }}"
          BRANCH_NAME="release/$RELEASE_VERSION"
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Create and push release branch
          git checkout -b $BRANCH_NAME
          git push origin $BRANCH_NAME
          
          echo "Created release branch: $BRANCH_NAME"

  # Notification and cleanup
  release-notification:
    name: Release Notification
    runs-on: ubuntu-latest
    needs: [prepare-release, create-github-release, deploy-release, post-release-validation]
    if: always()
    steps:
      - name: Generate release summary
        run: |
          RELEASE_VERSION="${{ needs.prepare-release.outputs.release-version }}"
          RELEASE_URL="${{ needs.create-github-release.outputs.release-url }}"
          ENVIRONMENT="${{ inputs.environment || 'prod' }}"
          
          cat > release-summary.md << EOF
          # ðŸŽ‰ Release $RELEASE_VERSION Complete!
          
          **Environment:** $ENVIRONMENT
          **Release Type:** ${{ needs.prepare-release.outputs.release-type }}
          **Status:** ${{ job.status }}
          **Release URL:** $RELEASE_URL
          
          ## Deployment Results
          - Deploy Status: ${{ needs.deploy-release.result }}
          - Validation Status: ${{ needs.post-release-validation.result }}
          
          ## Next Steps
          - Monitor application performance
          - Watch for user feedback
          - Prepare for next iteration
          
          **Release completed at:** $(date -u +%Y-%m-%dT%H:%M:%SZ)
          EOF

      - name: Post to Slack (Production releases)
        if: (inputs.environment == 'prod' || github.ref_type == 'tag') && vars.SLACK_WEBHOOK_URL != ''
        run: |
          RELEASE_VERSION="${{ needs.prepare-release.outputs.release-version }}"
          STATUS_EMOJI="ðŸŽ‰"
          
          if [ "${{ job.status }}" != "success" ]; then
            STATUS_EMOJI="âš ï¸"
          fi
          
          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"$STATUS_EMOJI Signant Health Demo $RELEASE_VERSION released to production!\",
              \"blocks\": [
                {
                  \"type\": \"section\",
                  \"text\": {
                    \"type\": \"mrkdwn\",
                    \"text\": \"*Production Release Complete*\n Version: $RELEASE_VERSION\n Status: ${{ job.status }}\n Release Notes: ${{ needs.create-github-release.outputs.release-url }}\"
                  }
                }
              ]
            }" \
            ${{ vars.SLACK_WEBHOOK_URL }}

      - name: Email notification (Critical releases)
        if: needs.prepare-release.outputs.is-hotfix == 'true' || inputs.release_type == 'major'
        run: |
          echo "ðŸ“§ Critical release notification would be sent here"
          echo "Release: ${{ needs.prepare-release.outputs.release-version }}"
          echo "Type: ${{ needs.prepare-release.outputs.release-type }}"